{"ast":null,"code":"import _asyncToGenerator from \"/home/chechaandrey/Projects/itransition/course/admin/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, of } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nexport class FetchServiceError extends Error {}\nexport class FetchService {\n  constructor(http) {\n    this.http = http;\n    this.storage = {};\n\n    if (!(this.http instanceof HttpClient)) {\n      throw new FetchServiceError('An instance of the \"HttpClient\" class must be passed to the constructor');\n    }\n  }\n\n  get(namespace, options = {}) {\n    return this.fetch(namespace, 'GET', null, options);\n  }\n\n  post(namespace, data = null, options = {}) {\n    return this.fetch(namespace, 'POST', data, options);\n  }\n\n  fetch(namespace, method, data, options) {\n    namespace += method;\n\n    if (!this.storage.hasOwnProperty(namespace)) {\n      throw new FetchServiceError(`The entity for \"${namespace}\"(${method}) is not defined`);\n    }\n\n    let entry = this.storage[namespace];\n\n    if (entry.query) {\n      entry.query.unsubscribe();\n      entry.query = null;\n    }\n\n    let query;\n\n    if (method === 'GET') {\n      query = this.http.get(entry.url, Object.assign({}, entry.options, options));\n    } else {\n      query = this.http.post(entry.url, data, Object.assign({}, entry.options, options));\n    }\n\n    entry.query = query.pipe(catchError(e => {\n      entry.query.unsubscribe();\n      entry.query = null;\n      this.pushError(namespace, e);\n      return of(null);\n    })).subscribe(data => {\n      this.push(namespace, data);\n    });\n    return this;\n  } // Observable\n\n\n  source(namespace, method = \"GET\") {\n    namespace += method;\n\n    if (!this.storage.hasOwnProperty(namespace)) {\n      throw new FetchServiceError(`The entity for \"${namespace}\" is not defined`);\n    }\n\n    let entry = this.storage[namespace];\n    return new Observable(observer => {\n      let f = data => {\n        observer.next(data); // call-back .subscribe\n      };\n\n      entry.cbs.push(f);\n      return {\n        unsubscribe: () => {\n          entry.cbs = entry.cbs.filter(fn => {\n            return fn !== f;\n          });\n        }\n      };\n    });\n  }\n\n  error(namespace, method = \"GET\") {\n    namespace += method;\n\n    if (!this.storage.hasOwnProperty(namespace)) {\n      throw new FetchServiceError(`The entity in Error for \"${namespace}\" is not defined`);\n    }\n\n    let entry = this.storage[namespace];\n    return new Observable(observer => {\n      let f = data => {\n        observer.next(data); // call-back .subscribe\n      };\n\n      entry.ecbs.push(f);\n      return {\n        unsubscribe: () => {\n          entry.ecbs = entry.ecbs.filter(fn => {\n            return fn !== f;\n          });\n        }\n      };\n    });\n  }\n\n  push(namespace, data) {\n    let entry = this.storage[namespace];\n    entry.middleware.call(this, data).then(data => {\n      this.storage[namespace].cbs.map(f => {\n        f.call(null, data);\n      });\n    }).catch(e => {\n      throw e;\n    });\n    return this;\n  }\n\n  pushError(namespace, data) {\n    this.storage[namespace].ecbs.map(f => {\n      f.call(null, data);\n    });\n  }\n\n  addEntry(namespace, method, url, middleware = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (a) {\n      return a;\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(), options = {}) {\n    this.storage[namespace + method] = {\n      cbs: [],\n      ecbs: [],\n      url,\n      options,\n      middleware,\n      query: null\n    };\n    return this;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}